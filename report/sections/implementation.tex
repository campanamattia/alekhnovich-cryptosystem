\section{Alekhnovich's Cryptosystem}
\subsection{Overview}
The purpose of this paper is not to explain in detail the operation of Alekhnovich algorithm and why, unlike those currently implemented, it could offer advantages in the face of quantum computers. To better understand the various steps, it is necessary to provide an overview of its operation:
\subparagraph{The Algorithm} The algorithm begins by generating two random matrices, $A\in \mathbb{Z}^{k\times n}_2$ and $S\in \mathbb{Z}^{l\times k}_2$. After, it generates a third random matrix, $E\in \mathbb{Z}^{l\times n}_2$. The rows of E are chosen from random and independent vectors of weight $t$ (the weight is computed as $\sqrt{n}$).The algorithm then defines the matrix $Y$ as $Y = SA + E$.


The matrices $Y$ and $A$ represent the public key of the algorithm. The public key is shared with anyone who wants to send encrypted messages to the sender.
The plain text to encrypt space is $\mathbb{M} = C \subset \{0,1\}^l $ where $C$ is an error-correcting code. The error-correcting code implies an algorithm used to ensure that the message can be recovered even if it is corrupted by noise.
Now following steps are required for a secure exchange of information:
\begin{itemize}
 \item To encrypt the message, the sender performs the following steps:
    \begin{enumerate}
     \item The sender generates a random $t$-weight vector $e$ of $\mathbb{F}_2^n $.
     \item The sender multiplies $e^T$ by the public key $Y$ and $A$.
     \item The sender adds the message $m$ to the result of the multiplication $Ye^T$.
    \end{enumerate}
    The encrypted message is then given by the following vector: $$C(m) = (Ae^T, m+Ye^T)$$.
    \item To decrypt the message, the receiver performs the following steps:
    \begin{enumerate}
     \item The receiver multiplies the first part of the encrypted message, $Ae^T$, by the secret key $S$ getting $SAe^T = Ye^T-Ee^T $.
     \item The receiver subtracts from the second part of the encrypted message, $m+Ye^T$, the result of the previous multiplication.
    \end{enumerate}
    Now the receiver finds itself with a vector of the type: $$(m+Ye^T) - (Ye^T-Ee^T) = m + Ee^T$$
\end{itemize}
The algorithm works by exploiting the fact that the product of the matrix $E$ and the vector $e$ of weight $t$ is likely to be zero. This is due to the random positions of the few 1s in both both the rows of $E$ and the vector $e$; the probability that even just one of these coincides is very low.
In the worst case, the code will distance itself from the original with a maximum Hamming distance of $t$, which is manageable with the error-correcting algorithm of the chosen code.

\subsection{Key Generation}
The initial step involves generating the matrices \(A\), \(S\), and \(E\) for both public and private key generation. The former two matrices, represented by \textit{uint64\_t}, are produced utilizing the \href{https://prng.di.unimi.it}{xoshiro256} PRNG. To leverage this library, we must initialize its seed vector comprising 4 \textit{uint64\_t} elements. This initialization can be achieved using the \texttt{randombytes(x, X\_BYTES)} API provided by \href{https://randombytes.cr.yp.to/index.html}{librandombytes}:
\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Seed Initialization}
\label{SI}
\For{\(i\) $\leftarrow$ 0 \KwTo 3}{
    $seed \leftarrow$ char[X\_BYTES]\;
    \texttt{randombytes(seed, X\_BYTES)}\;
    \For{\(j\) $\leftarrow$ 0 \KwTo X\_BYTES-1}{
        $s[i] = s[i] \ll 8$\;
        \(s[i]\) $|=$ \(seed[j]\)\;
    }
}
\end{algorithm}
\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Matrix Generation}
\label{GAS}
\KwResult{matrix $M$}
\tcc{Initialization of the seed}
\texttt{init\_seed()}$^{\ref{SI}}$\;
\tcc{Filling the matrix}
$M \leftarrow$ uint64\_t[ROWS][COLUMNS]\;
\For{\(i\) $\leftarrow$ 0 \KwTo ROWS-1}{
    \For{\(j\) $\leftarrow$ 0 \KwTo COLUMNS-1}{
        $M$[i][j] $\leftarrow$ \texttt{xoshiro256.next()}\;
    }
}
\Return{\texttt{M}}\;
\end{algorithm}

Now that we have the function to generate matrices \(A\) and \(S\), we need to generate matrix \(E\) to compose our public key \(Y\). As described by Alekhnovich, matrix \(E\) is composed of weight-\(t\) vectors:

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Generate array with \(T\) 1s}
\label{GA}
\KwResult{array of uint64\_t with T 1s}
\SetKwProg{Fn}{Function}{:}{}
\SetKwFunction{fetchBit}{fetchBit}\label{FB}
\Fn{\fetchBit{integer, shift}}{
    $bit \leftarrow (integer \gg shift) \& 1$\;
    \Return{\texttt{bit}}
}
$array \leftarrow$ uint64\_t [DIM]\;
\For{$t \leftarrow 1$ \KwTo $T$}{
    \Repeat{\texttt{fetch\_bit}(array[index], shift) = 1}{
        $p \leftarrow$ \texttt{xoshiro256.next()}\;
        $index \leftarrow p \pmod{\text{array}}$\;
        $shift \leftarrow p \pmod{\text{uint64\_t}}$\;
    }
    array[p / size of(uint64\_t)] $|=$ (1 $\ll$ (p $\pmod{\text{uint64\_t}}$)\;
}
\Return{\texttt{array}}
\end{algorithm}

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Matrix E\label{GE}}
\KwResult{matrix $E$ with T 1s in each row}
\tcc{Initialization of the seed}
\texttt{init\_seed()}\;
\tcc{Filling the matrix}
$M \leftarrow$ uint64\_t [ROWS][COLUMNS]\;
\For{\(i\) $\leftarrow$ 0 \KwTo ROW-1}{
    row$\leftarrow$ \texttt{gen\_array()}\;
    $M[i] \leftarrow$ row;
}
\Return{\texttt{matrix}}\;
\end{algorithm}

After doing so, it is necessary to compute the key \(Y\), which together with the matrix \(A\), represents my public key. To do so, i need first some helper functions to manipulate the matrix and access to the singles bits:

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Transpose bit matrix \label{TM}}
\KwData{Matrix M}
\KwResult{M transposed}
$T \leftarrow$ uint64\_t[$M$.COLUMNS * 64][$M$.ROWS / 64] filled with 0s\;
\For{$i \leftarrow 0$ \KwTo $M$.ROWS-1}{
    \For{$j \leftarrow 0$ \KwTo $M$.COLUMNS-1}{
        \For{$k \leftarrow 0$ \KwTo 63}{
            bit $\leftarrow$ \(M[i][j] \gg k\) $\&$ 1\;
            $M$[j * 64 - (63 - k)][i] $|=$ bit $\ll$ 63 - k\;
        }
    }
}
\Return{\texttt{M}}\;
\end{algorithm}

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Bit-wise AND + XOR \label{BAX}}
\KwData{Vectors $A$, $V$}
\KwResult{The bit-wise AND followed by a XOR}
$result\_and \leftarrow$ uint64\_t[$n$]\;
\For{$i \leftarrow 0$ \KwTo $n-1$}{
    $result\_and[i] \leftarrow A[i] \& V[i]$\;
}
$result\_xor \leftarrow 0$\;
\For{$i \leftarrow 0$ \KwTo $n-1$}{
    $result\_xor \leftarrow result\_xor \oplus result\_and[i]$\;
}
$result \leftarrow$ 0\;
\For{$i \leftarrow 0$ \KwTo $63$}{
    $bit \leftarrow$ ($result\_xor \gg i$) \& 1\;
    $result \leftarrow result \oplus bit$\;
}
\Return{\texttt{result}}\;
\end{algorithm}

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Sum of matrix \label{SM}}
\KwData{Matrix $M$, $N$}
\KwResult{Sum of $M$ and $N$}
\For{$i \leftarrow 0$ \KwTo ROWS-1}{
    \For{$j \leftarrow 0$ \KwTo COLUMNS-1}{
        $M$[i][j] $|= N$[i][j]\;
    }
}
\Return{\texttt{M}}
\end{algorithm}

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Compute Y \label{CY}} 
\KwData{matrix $A$, $S$, $E$}
\KwResult{matrix $Y$}
$T$ $\leftarrow$ \texttt{transposed($A$)} $^{\ref{TM}}$\;
$Y \leftarrow$ uint64\_t[ROWS][COLUMNS]\;
\tcc{Compute $S*A$}
\For{$i \leftarrow 0 $ \KwTo $S$.ROWS-1}{
    \For{\(j \leftarrow 0\) \KwTo $T$.ROWS-1}{
        $bit \leftarrow$ \texttt{bax($S$[i], $T$[j])}$^{\ref{BAX}}$\;
        $Y$[i][j / size of(uint64\_t)] $|= bit \ll (j \pmod{\text{size of uint64\_t}}$)\;
    }
}
\tcc{Compute $Y+E$}
$Y \leftarrow$ \texttt{matrix\_sum($Y$, $E$)$^{\ref{SM}}$}\;
\Return{\texttt{Y}}
\end{algorithm}

\subsection{Encryption}
After made public the $Y$ and $A$ keys, now it's possible to encrypt the messages. The sender other than write down the message to send, needs to generate a random vector long $l$ and of weight $t$.
To generate this vector it can be used the same piece of code used to generate the single row of matrix E \texttt{gen\_array()}$^{\ref{GA}}$. Now it time to computes the encrypted message concatenating two parts:
\begin{algorithm}
\DontPrintSemicolon
\caption{First half message}\label{FH}
\KwData{Matrix A, vector V}
\KwResult{Product between A and V}
$array \leftarrow$ uint64\_t[ROWS]\;
\For{$i \leftarrow 0$ \KwTo ROWS-1}{
    
}
\Return{\texttt{array}}
\end{algorithm}

\subsection{Decryption}
\subsection{Error Code}
