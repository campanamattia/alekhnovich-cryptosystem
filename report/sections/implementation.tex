\section{Alekhnovich's Cryptosystem}
\subsection{Overview}
The purpose of this paper is not to explain in detail the operation of Alekhnovich algorithm and why, unlike those currently implemented, it could offer advantages in the face of quantum computers. To better understand the various steps, it is necessary to provide an overview of its operation:
\subparagraph{The Algorithm} The algorithm begins by generating two random matrices, $A\in \mathbb{Z}^{k\times n}_2$ and $S\in \mathbb{Z}^{l\times k}_2$. After, it generates a third random matrix, $E\in \mathbb{Z}^{l\times n}_2$. The rows of E are chosen from random and independent vectors of weight $t$ (the weight is computed as $\sqrt{n}$).The algorithm then defines the matrix $Y$ as $Y = SA + E$.


The matrices $Y$ and $A$ represent the public key of the algorithm. The public key is shared with anyone who wants to send encrypted messages to the sender.
The plain text to encrypt space is $\mathbb{M} = C \subset \{0,1\}^l $ where $C$ is an error-correcting code. The error-correcting code implies an algorithm used to ensure that the message can be recovered even if it is corrupted by noise.
Now following steps are required for a secure exchange of information:
\begin{itemize}
 \item To encrypt the message, the sender performs the following steps:
    \begin{enumerate}
     \item The sender generates a random $t$-weight vector $e$ of $\mathbb{F}_2^n $.
     \item The sender multiplies $e^T$ by the public key $Y$ and $A$.
     \item The sender adds the message $m$ to the result of the multiplication $Ye^T$.
    \end{enumerate}
    The encrypted message is then given by the following vector: $$C(m) = (Ae^T, m+Ye^T)$$.
    \item To decrypt the message, the receiver performs the following steps:
    \begin{enumerate}
     \item The receiver multiplies the first part of the encrypted message, $Ae^T$, by the secret key $S$ getting $SAe^T = Ye^T-Ee^T $.
     \item The receiver subtracts from the second part of the encrypted message, $m+Ye^T$, the result of the previous multiplication.
    \end{enumerate}
    Now the receiver finds itself with a vector of the type: $$(m+Ye^T) - (Ye^T-Ee^T) = m + Ee^T$$
\end{itemize}
The algorithm works by exploiting the fact that the product of the matrix $E$ and the vector $e$ of weight $t$ is likely to be zero. This is due to the random positions of the few 1s in both both the rows of $E$ and the vector $e$; the probability that even just one of these coincides is very low.
In the worst case, the code will distance itself from the original with a maximum Hamming distance of $t$, which is manageable with the error-correcting algorithm of the chosen code.

\subsection{Key Generation}
The initial step involves generating the matrices \(A\), \(S\), and \(E\) for both public and private key generation. The former two matrices, represented by \textit{uint64\_t}, are produced utilizing the \href{https://prng.di.unimi.it}{xoshiro256} PRNG. To leverage this library, we must initialize its seed vector comprising 4 \textit{uint64\_t} elements. This initialization can be achieved using the \texttt{randombytes(x, X\_BYTES)} API provided by \href{https://randombytes.cr.yp.to/index.html}{librandombytes}:

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Matrix Generation}
\label{GAS}
\KwResult{uint64\_t[ ][ ] $M$}
Let X\_BYTES be a constant with a value of 8\;
\tcp*{Initialization of the seed}
\For{\(i\) $\leftarrow$ 0 \KwTo 3}{
    $seed \leftarrow$ char[X\_BYTES]\;
    \texttt{randombytes(seed, X\_BYTES)}\;
    \For{\(j\) $\leftarrow$ 0 \KwTo X\_BYTES-1}{
        $s[i] = s[i] \ll 8$\;
        \(s[i]\) $|=$ \(seed[j]\)\;
    }
}
\tcp*{Initialization of the matrix}
$M \leftarrow$ uint64\_t[ROWS][COLUMNS]\;
\For{\(i\) $\leftarrow$ 0 \KwTo ROWS-1}{
    \For{\(j\) $\leftarrow$ 0 \KwTo COLUMNS-1}{
        $M$[i][j] $\leftarrow$ \texttt{xoshiro256.next()}\;
    }
}
\Return{\texttt{M}}\;
\end{algorithm}

Now that we have the function to generate matrices \(A\) and \(S\), we need to generate matrix \(E\) to compose our public key \(Y\). As described by Alekhnovich, matrix \(E\) is composed of weight-\(t\) vectors:

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Matrix E}
\label{GE}
\KwResult{uint64\_t[ ][ ] $E$ //where every row has $T$ 1s}
\tcp*{Initialize the seed of \texttt{xoshiro} as before}
Declare a uint64\_t \texttt{matrix}[ROWS][COLUMNS]\;
\For{\(i\) $\leftarrow$ 0 \KwTo ROW-1}{
    uint64\_t row[COLUMNS] $\leftarrow$ 0\;
    \For{$t \leftarrow 1$ \KwTo $T$}{
        \Repeat{row[p / size of(uint64\_t)] $<<$ (p mod size of uint64\_t) = 1}{
            Generate random position $p$ between $0$ and $K-1$\;
        }
        row[p / size of(uint64\_t)] $|=$ (1 $<<$ (p mod size of uint64\_t))\;
    }
    \texttt{matrix}[i] $\leftarrow$ row;
}
\Return{\texttt{matrix}}\;
\end{algorithm}

After doing so, it is necessary to compute the key \(Y\), which together with the matrix \(A\), represents my public key:

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Compute Y \label{CY}} 
\SetKwProg{Fn}{Function}{:}{}
\KwData{uint64\_t[ ][ ] $A$, $S$, $E$}
\KwResult{uint64\_t[ ][ ] $Y$}
\tcp*{To simplify the row column product}
\SetKwFunction{transposed}{transposed}
\Fn{\transposed{M}}{
    \KwData{Matrix M}
    \KwResult{M transposed}
    $T \leftarrow$ uint64\_t[$M$.COLUMNS * 64][$M$.ROWS / 64] filled with 0s\;
    \For{$i \leftarrow 0$ \KwTo $M$.ROWS-1}{
        \For{$j \leftarrow 0$ \KwTo $M$.COLUMNS-1}{
            \For{$k \leftarrow 0$ \KwTo 63}{
                bit $\leftarrow$ \(M[i][j] \gg k\) $\&$ 1\;
                $M$[j * 64 - (63 - k)][i] $|=$ bit $\ll$ 63 - k\;
            }
        }
    }
    \Return{\texttt{M}}\;
}
$T$ $\leftarrow$ \texttt{transposed($A$)}\;
\tcp*{Bit-wise AND + XOR}
\SetKwFunction{bax}{bax}
\Fn{\bax{a, b}}{
    \KwData{Two vectors of uint64\_t}
    \KwResult{The bit-wise AND followed by a XOR}
    $result\_and \leftarrow$ array of size $n$\;
    \For{$i \leftarrow 0$ \KwTo $n-1$}{
        $result\_and[i] \leftarrow v1[i] \& v2[i]$\;
    }
    $result\_xor \leftarrow 0$\;
    \For{$i \leftarrow 0$ \KwTo $n-1$}{
        $result\_xor \leftarrow result\_xor \oplus result\_and[i]$\;
    }
    $result \leftarrow$ 0\;
    \For{$i \leftarrow 0$ \KwTo $63$}{
        $bit \leftarrow$ ($result\_xor >> i$) \& 1\;
        $result \leftarrow result \oplus bit$\;
    }
    \Return{\texttt{result}}\;
}
\tcp*{Compute Y}
$Y \leftarrow$ uint64\_t[ROWS][COLUMNS]\;
\For{\(i\) $\leftarrow$ 0 \KwTo $S$.ROWS-1}{
    \For{\(j \leftarrow 0\) \KwTo $T$.ROWS-1}{
        $bit \leftarrow$ \texttt{bax($S$[i], $T$[j])}\;
        $Y$[i][j / size of(uint64\_t)] $|= bit \ll (j \pmod{\text{size of uint64\_t}}$)\;
    }
}
\Return{\texttt{Y}}
\end{algorithm}

\subsection{Encryption}


\subsection{Decryption}
\subsection{Error Code}