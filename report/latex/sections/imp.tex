\chapter{Alekhnovich's Cryptosystem}

This paper does not delve into the intricate details of the Alekhnovich algorithm or its potential advantages against quantum computers compared to existing algorithms. However, to provide context for further discussion, a brief overview of its operation is included.

\section{The Algorithm}
The Alekhnovich cryptosystem\cite{DBLP:journals/cc/Alekhnovich11a} is based on hard problems in coding theory, particularly the problem of decoding random linear codes, which is believed to be hard for both classical and quantum computers. The algorithm begins by generating two random matrices: $\mathbf{A} \in \mathbb{Z}^{k \times n}_2$ and $\mathbf{S} \in \mathbb{Z}^{l \times k}_2$. Here, $\mathbf{A}$ acts as the generator matrix of a random linear code, and $S$ serves as a scrambling matrix that transforms the code generated by $\mathbf{A}$.

Subsequently, a third random matrix $\mathbf{E} \in \mathbb{Z}^{l \times n}_2$ is generated, where each row of $\mathbf{E}$ is a random vector with a Hamming weight of $t = \sqrt{n}$. The matrix $\mathbf{Y}$ is then defined as $\mathbf{Y} = \mathbf{SA} + \mathbf{E}$. In this context, $\mathbf{Y}$ can be interpreted as a noisy version of the matrix $\mathbf{SA}$, where the noise is introduced by $\mathbf{E}$. This step ensures that the problem of distinguishing between random vectors and codewords of the code defined by $\mathbf{A}$ becomes computationally hard.

The public key of the algorithm consists of the matrices $\mathbf{Y} \in \mathbb{Z}^{l \times n}_2$ and $\mathbf{A} \in \mathbb{Z}^{k \times n}_2$, which are shared with anyone wishing to send encrypted messages. The plaintext space is $\mathbf{m} \in \mathcal{C} \subset \{0,1\}^l$, where $\mathcal{C}$ is an error-correcting code characterized by its length, dimension, and minimum distance. The code $\mathcal{C}$ is crucial as it allows for the recovery of the message even if it has been corrupted by noise.

The encryption and decryption process is as follows:

\begin{itemize}
 \item \textbf{Encryption:}
    \begin{enumerate}
     \item The sender generates a random $t$-weight vector $\mathbf{e} \in \mathbb{F}_2^n$.
     \item The sender computes the vectors $\mathbf{Ae}^T$ and $\mathbf{Ye}^T$, where $\mathbf{A}$ and $\mathbf{Y}$ are the public key matrices.
     \item The encrypted message is then formed by adding the plain text message $\mathbf{m}$ to $\mathbf{Ye}^T$: $$\texttt{C}(\mathbf{m}) = (\mathbf{Ae}^T, \mathbf{m}+\mathbf{Ye}^T).$$
    \end{enumerate}

 \item \textbf{Decryption:}
    \begin{enumerate}
     \item The receiver multiplies the first part of the encrypted message, $\mathbf{Ae}^T$, by the secret key $\mathbf{S}$ to obtain $\mathbf{SAe}^T = \mathbf{Ye}^T - \mathbf{Ee}^T$.
     \item The receiver then subtracts this from the second part of the encrypted message, $\mathbf{m} + \mathbf{Ye}^T$, yielding: $$(\mathbf{m} + \mathbf{Ye}^T) - (\mathbf{Ye}^T - \mathbf{Ee}^T) = \mathbf{m} + \mathbf{Ee}^T.$$
     \item Since $\mathbf{E}$ is sparse, the vector $\mathbf{Ee}^T$ is expected to have a low weight, and the error-correcting code $\mathcal{C}$ is employed to recover the original message $\mathbf{m}$ from $\mathbf{m} + \mathbf{Ee}^T$.
    \end{enumerate}
\end{itemize}

The security of the algorithm relies on the difficulty of decoding a random linear code, a problem that remains hard even when a certain number of errors (up to $t$) are introduced. The product of the matrix $\mathbf{E}$ and the vector $e$ of weight $t$ is likely to be zero due to the sparsity of $\mathbf{E}$ and $\mathbf{e}$. Specifically, the probability of overlap between non-zero entries is low, estimated as $P(\langle \mathbf{e}, \mathbf{E_i} \rangle = 0) \approx 1 - \frac{t^2}{n}$.

\subsection{Parameters}
The cryptosystem's implementation requires careful selection of parameters to ensure both security and efficiency. The matrix dimensions and message length must satisfy the condition $$k + l < Rn,$$ where $R$ is a constant less than 1. This inequality ensures that the system remains overdetermined, which is necessary for the security guarantees provided by the underlying hard problem.

An essential consideration in implementation is the choice of matrix dimensions that fit within the constraints of computer architecture. While selecting dimensions that are multiples of the architecture's word size (e.g., 64 bits) can improve computational efficiency, this can also introduce potential security risks by making the structure of the matrices more predictable. Therefore, it is recommended to select dimensions that are close to, but not exactly multiples of, 64 bits.

Additionally, the following key points should be noted:
\begin{itemize}
    \item The weight of the error vector $t$ is chosen as $$t = \sqrt{l},$$ where $l$ is the length of the message.
    \item The error probability of the transmission channel, based on the binary symmetric channel model, is $$p = \frac{t^2}{n}.$$
\end{itemize}

\textit{For our implementation, the following parameter values will be used: 
$l = 1300$ bits, $t = 144$ bits, $k = 2^{6}$ bits, $n = 2^{17}$ bits.} Moreover, to maintain the hardness of the decoding problem, it is crucial that the error weight $t$ is high enough to ensure that the decoding problem remains computationally intractable.

\section{Implementation}

To facilitate secure message exchange, we must generate public and private keys. For efficient resource usage, we'll represent matrices with integers, treating individual bits as matrix cells. We will employ robust random number generation techniques using the following libraries:
\begin{itemize}
    \item \textbf{librandombytes\cite{randombytes}:} generates cryptographically secure random seeds.
    \item \textbf{xoshiro256 PRNG\cite{DBLP:journals/toms/BlackmanV21}:} efficiently generates pseudo-random sequence of bits.
\end{itemize}

\subsection{Helper Functions}
For clarity and modularity, the following helper functions are introduced to handle bitwise operations, matrix transposition, and seed initialization, which are essential for the key generation and cryptographic processes.

\paragraph{Seed Initiation}
This function is crucial for preparing the seed used by the \textit{xoshiro256} PRNG, ensuring that the sequences generated are cryptographically secure and unpredictable.

\begin{algorithm}[H]
\caption{\texttt{init\_seed}}
\label{IS}
\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\fori}{$i$ \KwTo\Range{$4$}}
\newcommand{\forj}{$j$ \KwTo\Range{$8$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwResult{Initialized seed vector $\mathbf{s}$ for pseudo random number generation}
\BlankLine
\For{\fori}{
    $\mathbf{seed} \leftarrow$ array\;
    \texttt{randombytes(seed, 8)}\tcc*{librandombytes API}
    \For{\forj}{
        $s_i \leftarrow s_i \ll 8$\;
        $s_i \leftarrow s_i \,\texttt{|}\, seed_j$ \tcc*{Bit-wise OR operation}
    }
}
\end{algorithm}

\paragraph{Bit Manipulation Functions}
To facilitate operations on individual bits within matrix cells, the following utility functions are defined:

\begin{itemize}
    \item \texttt{fetch\_bit($e,\,k$)}: This function returns the bit at the $k^{th}$ position of the element $e$.
    \item \texttt{shift\_bit($b,\,s$)}: This function shifts the bit $b$ left by $s$ positions.
\end{itemize}

\paragraph{Transposition}
To optimize bitwise operations on matrices, an efficient strategy for transposing individual bits is necessary. This involves converting rows of matrix into columns.

\begin{algorithm}[H]
\caption{\texttt{matrix\_transposed}}
\label{TM}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\forrow}{$i$ \KwTo\Range{$m.rows$}}
\newcommand{\forcol}{$j$ \KwTo\Range{$m.columns$}}
\newcommand{\forbit}{$k$ \KwTo\Range{$sizeof$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{$\mathbf{M}\in \mathbb{Z}_2^{l \times n}$}
\KwOut{$\mathbf{T}\in \mathbb{Z}_2^{m\times p}$}
\KwData{$m = n \times \text{sizeof}$; $p = \frac{l}{\text{sizeof}}$}
\BlankLine
$\mathbf{T} \leftarrow$ matrix\;
\For{\forrow}{
    \For{\forcol}{
        \For{\forbit}{
            $bit \leftarrow$ \texttt{fetch\_bit($m_{ij}, k$)}\;
            $y \leftarrow j \times \texttt{sizeof}\, + k$\;
            $w \leftarrow \left\lfloor \frac{i}{\texttt{sizeof}} \right\rfloor$\;
            $s \leftarrow \texttt{sizeof} - (i \bmod \texttt{sizeof}) - 1$\;
            $t_{yw} \leftarrow t_{yw} \,\texttt{|}\, \texttt{shift\_bit}(\text{bit}, s)$\;
        }
    }
}
\Return{$\mathbf{T}$}\;
\end{algorithm}


\paragraph{Bit-wise AND \& XOR Operations}
In this scenario, where individual matrix elements are represented by single bits rather than entire cells, it is essential to employ bitwise operations for the row-by-column product between matrices. Specifically, a bitwise AND operation is used to combine corresponding bits from the two matrices, followed by a bitwise XOR operation to accumulate the results. This approach ensures that the operations are correctly applied at the bit level.

\begin{algorithm}[H]
\caption{\texttt{bax}}
\label{BAX}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\forlength}{$i$ \KwTo\Range{$l$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{$\mathbf{a,v} \in \mathbb{Z}_2^l$}
\KwOut{result $\in \mathbb{Z}_2$}
\BlankLine
$result \leftarrow 0$\;
\For{\forlength}{
$and \leftarrow a_i\,\&\, v_i$\tcc*{Bit-wise AND operation}
$result \leftarrow result \,\texttt{|}\, and$\;
}
$result \leftarrow \texttt{count\_ones(result)}\pmod{2}$\tcc*{Simplified XOR}
\Return{result};
\end{algorithm}

\subsection{Key Generation}

The generation of keys is critical to the security of the cryptographic system. Here, we define a sequence of steps to generate both public and private keys efficiently while ensuring robustness against potential attacks. These keys are essential for encrypting and decrypting messages securely in subsequent processes.

\paragraph{Matrix A}

Following the referenced work, matrix $A$ has dimensions $k \times n$ and contains random values. We'll use the following function to generate $A$ after initializing the seed:

$$
\mathbf{A} \leftarrow \texttt{random\_matrix}(a.rows,\,a.columns)
$$ 

\begin{algorithm}[H]
\caption{\texttt{random\_matrix}}
\label{GRM}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\forrow}{$i$ \KwTo\Range{rows}}
\newcommand{\forcol}{$j$ \KwTo\Range{columns}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{\texttt{rows}, \texttt{columns} $\in \mathbb{N}$}
\KwOut{random matrix $\mathbf{M} \in \mathbb{Z}_2^{r\times c}$}
\BlankLine
\texttt{init\_seed()}\;
$\mathbf{M} \leftarrow$ matrix\;
\For{\forrow}{
    \For{\forcol}{
        $m_{ij} \leftarrow \texttt{xoshiro256.next()}$\tcc*{Filling the matrix}
    }
}
\Return{$\mathbf{M}$}\;
\end{algorithm}

\textbf{Note:} If $n$ represents the total number of bits, we can reduce $\mathbf{A}$'s size as follows:
$$
a.columns \leftarrow \frac{n}{s}
$$ 
where $s$ is the \texttt{size-of} the integer type chosen for our matrix.

\paragraph{Matrix S}
The same procedure is used for matrix $\mathbf{S}$, simply changing the input variables:
$$
\mathbf{S} \leftarrow \texttt{random\_matrix}(s.rows, \,s.columns)
$$

\paragraph{Matrix E}
Matrix $\mathbf{E}$ has different requirements: a predetermined number of 1-bits (defined as weight $t$) must be randomly positioned within each row. The following function generates $e.rows$ arrays, each containing $t$ randomly placed 1s:

$$
\mathbf{E} \leftarrow \texttt{weighted\_matrix}(e.rows, \,e.columns,\, t)
$$

\begin{algorithm}[H]
\caption{\texttt{weighted\_array}}
\label{WA}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\for}{count \KwTo\Range{$t$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{l, t $\in \mathbb{N}$}
\KwOut{random weighted vector $\mathbf{a} \in \mathbb{F}_2^{l}$}

\BlankLine
\texttt{init\_seed()}\;
$\mathbf{a} \leftarrow$ array\;
\For{\for}{
    \Repeat{$\text{\texttt{fetch\_bit}}(a_i, s) \neq 1$}{
        $p \leftarrow \texttt{xoshiro256.next}()$\;
        $i \leftarrow \leftarrow \left\lfloor \frac{p}{\texttt{sizeof}} \right\rfloor$\;
        $s \leftarrow p \pmod{sizeof}$\;
    }
    $a_i = a_i \,\texttt{|}\, \texttt{shift\_bit}(1, s)$ \tcc*{Set the bit at calculated position}
}
\Return{$\mathbf{a}$}
\end{algorithm}


\paragraph{Matrix Y}
To compute matrix \(\mathbf{Y}\), we need to first transpose matrix \(\mathbf{A}\) so that its rows become columns. Then, we perform a bitwise row-by-column multiplication between the transposed matrix \(\mathbf{A}^T\) and matrix \(\mathbf{S}\). Finally, we add matrix \(\mathbf{E}\) to the resulting matrix to obtain the final matrix \(\mathbf{Y}\). The following pseudocode describes the process:

\begin{algorithm}[H]
\caption{\texttt{compute\_pub}}
\label{compute_pub}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\SetKwFunction{Range}{range}
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}
\newcommand{\forrow}{$i$ \KwTo\Range{l}}
\newcommand{\forcol}{$j$ \KwTo\Range{n}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{$\mathbf{A}\in \mathbb{Z}_2^{k \times n}, \mathbf{S}\in \mathbb{Z}_2^{l \times k}, \mathbf{E} \in \mathbb{Z}_2^{l \times n}$}
\KwOut{$\mathbf{Y} \in \mathbb{Z}_2^{l \times n}$}

\BlankLine
$\mathbf{T} \leftarrow \texttt{matrix\_transposed} (\mathbf{A})$\;

\For{\forrow}{
    \For{\forcol}{
        $y_{ij} \leftarrow \texttt{bax}(\mathbf{S}_j, \mathbf{T}_i)$ \tcc*{Bit-wise row-by-column product using \texttt{BAX}}
    }
}

\For{\forrow}{
    \For{\forcol}{
        $y_{ij} \leftarrow y_{ij} \,\texttt{|}\, e_{ij}$
    }
}

\Return{$\mathbf{Y}$}\;
\end{algorithm}


\subsection{Encryption}

Following the generation of cryptographic keys, these keys are employed in the encryption and decryption processes. For the encryption of messages, we select an appropriate message element from the cryptographic system, denoted as $\mathbf{m} \in \mathcal{C} \subseteq \{0,1\}^l$. Additionally, it is essential to generate a random vector of fixed weight $t$, which can be achieved using the function defined previously:
\[
\mathbf{e} \leftarrow \texttt{weighted\_array}(n, t)
\]

The encryption process itself is straightforward, requiring two function calls:
\begin{enumerate}
    \item $\mathbf{nnc} \leftarrow \texttt{compute\_nonce}(A, e)$\footnote{A nonce is a unique, one-time-use value used to ensure secure communication.}, which computes the row-by-column product, treating $\mathbf{e}$ as a single-column matrix.
    \item $\mathbf{cmp} \leftarrow \texttt{cipher}(\mathbf{Y}, \mathbf{e}, \mathbf{m})$, which not only performs a row-by-column product similar to the previous step but also integrates the message $\mathbf{m}$ into the result.
\end{enumerate}
The encrypted packet is then generated by the following function:
\[
\mathbf{packet} \leftarrow \texttt{encryption}(\mathbf{m}, \mathbf{A}, \mathbf{Y})
\]

\begin{algorithm}[H]
\caption{\texttt{encryption}}
\label{enc}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{$\mathbf{m} \in \mathcal{C}$, $\mathbf{A} \in \mathbb{Z}_2^{k\times n}$, $\mathbf{Y} \in \mathbb{Z}_2^{l \times n}$}
\KwOut{$\mathbf{enc} \in \mathbb{Z}_2^{k+l}$}
$\mathbf{e} \leftarrow \texttt{weighted\_array}(n, t)$\;
$\mathbf{nnc} \leftarrow \texttt{row\_column}(\mathbf{A}, \mathbf{e})$\;
$\mathbf{cmp} \leftarrow \texttt{row\_column}(\mathbf{Y}, \mathbf{e})$\;
$\mathbf{cmp} \leftarrow \texttt{sum\_array}(\mathbf{cmp}, \mathbf{m})$\;
$\mathbf{enc} \leftarrow \texttt{concat}(\mathbf{nnc}, \mathbf{cmp})$ \tcc*{Concatenate the two arrays}
\Return{$\mathbf{enc}$};
\end{algorithm}

\subsection{Decryption}
Upon receiving an encrypted message, the nonce is separated from the message, and the first part is utilized to compute the decryption key. Specifically, the private key $\mathbf{S}$ is applied as follows:
\[
\mathbf{SAe}^T \leftarrow \texttt{row\_column}(\mathbf{S}, \mathbf{nnc})
\]

This result is used as the decryption key, with the vector $\mathbf{key} = \mathbf{SA}\mathbf{e}^T$, applied as follows: \[\mathbf{key} = \mathbf{Ye}^T - \mathbf{Ee}^T.\]

Finally, the original message is retrieved by subtracting this key from the received code:
\[
\mathbf{cmp} - \mathbf{key} = \mathbf{m} + \mathbf{Ye}^T - \mathbf{Ye}^T + \mathbf{Ee}^T
\]
which simplifies to recover the message:
\[
\mathbf{message} \leftarrow \texttt{decryption}(\mathbf{packet}, \mathbf{S}).
\]

\begin{algorithm}[H]
\caption{\texttt{decryption}}
\label{dec}

\DontPrintSemicolon
\SetStartEndCondition{ }{}{}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine

\KwIn{$\mathbf{packet} \in \mathbb{Z}_2^{k+l}$, $\mathbf{S} \in \mathbb{Z}_2^{l\times n}$}
\KwOut{$\mathbf{dec} \in \mathbb{Z}_2^l$}
$\mathbf{key} \leftarrow \texttt{row\_column}(\mathbf{S}, \mathbf{packet}[..k])$ \tcc*{Sub-vector from 0 to k-1}
$\mathbf{dec} \leftarrow \texttt{sub\_array}(\mathbf{packet}[k..], \mathbf{key})$ \tcc*{Sub-vector from k to end}
\Return{$\mathbf{dec}$};
\end{algorithm}

Although it might seem that this operation yields the decrypted message, the presence of the term $\mathbf{Ee}^T$ introduces an error, which we address in the subsequent section on error correction.

\subsection{Error Correction}
At this stage, as previously mentioned, the message is represented as $\mathbf{m} + \mathbf{Ee}^T$. Despite the added error, the message $\mathbf{m}$ is equipped with error correction, allowing for the recovery of the original message despite the presence of $\mathbf{Ee}^T$.

One practical method is to send the same message multiple times, using different nonces, and then apply majority voting to determine the most likely correct bits after decryption.

